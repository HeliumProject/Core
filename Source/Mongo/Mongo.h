#pragma once

#include "API.h"

#include "Platform/Locks.h"
#include "Platform/Thread.h"

#include "Foundation/Log.h"
#include "Foundation/String.h"
#include "Foundation/ReferenceCounting.h"

#include "Reflect/Object.h"
#include "Reflect/TranslatorDeduction.h"

#include "ArchiveBson.h"

#include <mongoc/mongoc.h>

#include <functional>

#define HELIUM_MONGO_DEFAULT_PORT ( 27017 )

namespace Helium
{
	namespace Mongo
	{
		HELIUM_MONGO_API void Startup();
		HELIUM_MONGO_API void Shutdown();

		class HELIUM_MONGO_API Model : public Helium::Reflect::Object
		{
		public:
			// the unique-id of the model instance, generated by the client just before insert
			//  you should not insert an object twice, instead null out the id before inserting another copy
			Helium::Persist::BsonObjectId id;

			HELIUM_DECLARE_CLASS( Model, Helium::Reflect::Object );
			static void PopulateMetaType( Helium::Reflect::MetaStruct& type );
		};

		class Database;

		class HELIUM_MONGO_API Cursor
		{
		public:
			Cursor( Database* db = NULL, mongoc_cursor_t* cursor = NULL );
			Cursor( const Cursor& rhs );
			~Cursor();

			// test if our find succeeded
			inline bool IsValid();

			// get a single result of an expected type
			template< class DefaultType >
			Helium::StrongPtr< DefaultType > Next();

			// get a single result object from the cursor, specifying the type to allocate if one is not specified in the data
			Helium::StrongPtr< Model > Next( const Reflect::MetaClass* defaultType );

			// read a single object into an existing instance
			bool Next( const Helium::StrongPtr< Model >& object );

		private:
			mutable Database* db;
			mutable mongoc_cursor_t* cursor;
		};

		class HELIUM_MONGO_API Database : public Helium::NonCopyable
		{
		public:
			Database( const char* name = "" );
			~Database();

			// server ops
			void RequestShutdown();

			// db ops/preferences
			bool Connect( const char* serverUriWithDatabase );
#if !HELIUM_SHARED
			inline mongoc_client_t* GetClient();
			inline mongoc_database_t* GetDatabase();
#endif

			// thread verification
			inline void SetThread( Helium::ThreadId threadId = Thread::GetCurrentId() );
			inline bool IsCorrectThread() const;

			// server routines
			int64_t GetServerTime();

			// database routines
			bool Drop();

			// collection routines
			bool DropCollection( const char* collectionName );
			int64_t GetCollectionCount( const char* collectionName, bool estimated = true );
			bool CreateCappedCollection( const char* collectionName, int cappedSizeInBytes, int cappedMaxCount = 0 );

			// single insert
			bool Insert( const Helium::StrongPtr< Model >& object, const char* collectionName = NULL );

			// single update
			bool Update( const Helium::StrongPtr< Model >& object, const char* collectionName = NULL );

			// batch insert, default collection will be named for the type of collection objects
			bool Insert( Helium::StrongPtr< Model >* objects, size_t count, const char* collectionName = NULL );

			// single fetch
			bool Get( const Helium::StrongPtr< Model >& object, const char* collectionName = NULL );

			// index ops
			bool EnsureIndex( const char* collectionName, const bson_t* key, const char* name = NULL, int options = 0x0 );

			// find
			//  query == NULL will return all objects by default
			//  fields == NULL will populate all fields in result objects, populate to determine which fields are updated
			//  collection == NULL uses collection named for the type specified in the cursor object
			Cursor Find( const char* collectionName, const bson_t* query = NULL, int limit = 0, int skip = 0, int options = 0 );

			// remove
			//  collection == NULL uses collection named for the type specified in the cursor object
			//  query == NULL will remove all objects by default
			bool Remove( const char* collectionName, const bson_t* query = NULL );

		private:
			String name;
			ThreadId threadId;
			mongoc_client_t* client;
			mongoc_database_t* database;
		};
	}
}

#include "Mongo/Mongo.inl"