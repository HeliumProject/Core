#pragma once

#include "API.h"

#include "Platform/Locks.h"
#include "Platform/Thread.h"

#include "Foundation/Log.h"
#include "Foundation/String.h"
#include "Foundation/ReferenceCounting.h"

#include "Reflect/Object.h"
#include "Reflect/TranslatorDeduction.h"

#include "Persist/ArchiveBson.h"

#include <mongo-c/src/mongo.h>

#if HELIUM_CPP11
# include <functional>
#endif

#define HELIUM_MONGO_DEFAULT_PORT ( 27017 )

namespace Helium
{
	namespace Mongo
	{
		HELIUM_MONGO_API void        Initialize();
		HELIUM_MONGO_API void        Cleanup();
		HELIUM_MONGO_API const char* GetErrorString( int status );

		class HELIUM_MONGO_API Model : public Helium::Reflect::Object
		{
		public:
			// the unique-id of the model instance, generated by the client just before insert
			//  you should not insert an object twice, instead null out the id before inserting another copy
			Helium::Persist::BsonObjectId id;

			HELIUM_DECLARE_CLASS( Model, Helium::Reflect::Object );
			static void PopulateMetaType( Helium::Reflect::MetaStruct& type );
		};

		class Database;

		class HELIUM_MONGO_API Cursor
		{
		public:
			Cursor( Database* db = NULL, mongo_cursor* cursor = NULL );
			Cursor( const Cursor& rhs );
			~Cursor();

			// test if our find succeeded
			inline bool IsValid();

			// get a single result of an expected type
			template< class DefaultType >
			Helium::StrongPtr< DefaultType > Next();

			// get a single result object from the cursor, specifying the type to allocate if one is not specified in the data
			Helium::StrongPtr< Model > Next( const Reflect::MetaClass* defaultType );

			// read a single object into an existing instance
			bool Next( const Helium::StrongPtr< Model >& object );

		private:
			mutable Database*     db;
			mutable mongo_cursor* cursor;
		};

		class HELIUM_MONGO_API Database : public Helium::NonCopyable
		{
		public:
			Database( const char* name = "" );
			~Database();

			// db ops/preferences
			inline const char* GetName() const;
			void SetName( const char* name );
			void SetTimeout( int timeoutMilliseconds );
			bool Connect( const char* addr, uint16_t port = HELIUM_MONGO_DEFAULT_PORT );
			inline bool IsConnected( bool pingServer );
			inline mongo* GetConnection();

			// thread verification
			inline void SetThread( Helium::ThreadId threadId = Thread::GetCurrentId() );
			inline bool IsCorrectThread() const;

			// server routines
			int64_t GetServerTime( bool inMilliseconds = false );

			// database routines
			bool Drop();

			// collection routines
			bool DropCollection( const char* name );
			double GetCollectionCount( const char* name );
			bool CreateCappedCollection( const char* name, int cappedSizeInBytes, int cappedMaxCount = 0 );

			// single insert
			bool Insert( const Helium::StrongPtr< Model >& object, const char* collection = NULL );

			// single update
			bool Update( const Helium::StrongPtr< Model >& object, const char* collection = NULL );

			// batch insert, default collection will be named for the type of collection objects
			bool Insert( Helium::StrongPtr< Model >* objects, size_t count, const char* collection = NULL );

			// single fetch
			bool Get( const Helium::StrongPtr< Model >& object, const char* collection = NULL );

			// index ops
			bool EnsureIndex( const char* collection, const bson* key, const char* name = NULL, int options = 0x0 );

			// find
			//  query == NULL will return all objects by default
			//  fields == NULL will populate all fields in result objects, populate to determine which fields are updated
			//  collection == NULL uses collection named for the type specified in the cursor object
			Cursor Find( const char* collection, const bson* query = NULL, int limit = 0, int skip = 0, int options = 0 );

		private:
			Helium::String       name;
			bool                 isConnected;
			mongo                conn[1];
			Helium::ThreadId threadId;
		};
	}
}

#include "Mongo/Mongo.inl"